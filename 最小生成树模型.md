**第一部分--最小生成树(Kruskal)模型建立**
$(1)$数据初始化：
构建邻接矩阵来表示各城市之间经过距离和需求匹配后边权；
$(2)$排序：
将每两个顶点之间的边权$u_i$按照从小到大的顺序排列，并记录每条边$u_i$所连接的两点$v_k$和$v_m$
$(3)$选边：
按照排序出来的结果从小到大选边$u_i$并记录所连接的两点$v_p$和$v_q$，当且仅当以下三种情况出现停止选边或者跳过该条边：
第一：若新加入的这条边$e$可以和原来的树$T'$形成连通块，则跳过该条边；
第二：若无边可选，且所记录已连接的顶点不是全部顶点数量，则退出，不能构建最小生成树；
第三：若所选顶点数量已经达到全部顶点数量，则退出，最小生成树$T$已构建;
$(4)$构建树：
假如可以形成一颗树，那么就必然为一棵最小生成树$T$，并将其在地图上投影出来，以供后续模型比较，在这里不对$Kruskal$算法进行证明。
**第二部分--城市边权模型的建立**
$(1)$数据初始化：
输入城市距离的邻接矩阵$G_1(u,v)$，输入各个城市的信息需求量矩阵$G_2$:
$$G_1 = \begin{bmatrix}
0 & u_{12} &u_{13}&\ldots&u_{1k}\\
u_{21} & 0 &u_{23}&\ldots&u_{2k}\\
\vdots &  \vdots &   \vdots   &  \ddots    &\vdots\\
u_{k1} &u_{k2}& u_{k3}& \ldots  &0
\end{bmatrix}$$

$$G_2=\begin{bmatrix} N_1&N_2&N_3 &\ldots &N_k\end{bmatrix}$$

其中$N_i$表示第$i$个城市的信息需求量，$u_{ij}$表示第$i$个点到第$j$个点的距离。
$(2)$边权配重：
对于任意两点$v_p$,$v_q$我们取出其距离$u_i$,两个城市的需求$N_p$,$N_q$，则新的边权$u_{i}'$为：
$$u_{i}' = \frac {u_i}{N_p+N_q}$$

随着边两点的需求之和越大，则此边权越小；同理，当两点间距离越大时，此边权亦越小。特别的，当某两点的距离之和超过200km时，我们将$u_{i}'$置为-1，使其不被考虑，因为所铺设的线路最远只能到200km。
至此，我们可以得到新的边权图$G_{0}(u',v)$:
$$G_0 = \begin{bmatrix}
0 & u_{12}' &u_{13} '&\ldots&u_{1k}'\\
u_{21}' & 0 &u_{23}'&\ldots&u_{2k}'\\
\vdots &  \vdots &   \vdots   &  \ddots    &\vdots\\
u_{k1}' &u_{k2}'& u_{k3}'& \ldots  &0
\end{bmatrix}$$
**第三部分--求解最小生成树**
$(1)$数据初始化：
经过讨论，我们将城市边权模型代入最小生成树中，求解该模型下的树$T$，数据如下：
首先是城市距离的邻接矩阵$G_1(u,v)$：
（插入excel表格）
接下来是城市的需求矩阵$G_2$：
（插入excel表格）
最后根据城市边权模型建立矩阵$G_{0}(u',v)$：
（插入excel表格-最小生成树模型城市数据）
$(2)$代入模型计算：
经过程序计算，我们得出以下结果：
（插入图片--最小生成树广州图？）
**第四部分--模型缺点**
$(1)$边权模型的配重有可能不太符合实际，导致求出来的最小生成树所对应现实中的成本不是最优解，调整距离和两城市之间的需求配重是其主要的难点，这也意味着其预测结果精确值不是特别理想；
$(2)$有可能出现环来分流城市之间的流量，最小生成树不能判断这种情况；
**第五部分--参考资料**
https://www.cnblogs.com/nbalive2001/p/4979667.html	[贪心经典算法]Kruskal算法
https://www.cnblogs.com/skywang12345/p/3711496.html	Kruskal算法（一）之 c语言详解
https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/kruskal/udg/c/matrix_udg.c	    C: Kruskal算法生成最小生成树(邻接矩阵)

